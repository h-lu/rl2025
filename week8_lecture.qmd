---
title: "Week 8: Q-Learning 应用讨论与中期回顾"
---

# 回顾：Q-Learning 与 Off-Policy 学习

上周我们重点学习了 Q-Learning：

*   **类别:** 异策略 (Off-Policy) TD 控制算法。
*   **核心:** 直接学习最优动作值函数 Q\*(s, a)。
*   **更新规则:** Q(S, A) ← Q(S, A) + α [R + γ max_{a'} Q(S', a') - Q(S, A)]
*   **特点:**
    *   行为策略 (μ, e.g., ε-greedy) 用于探索和收集数据。
    *   目标策略 (π, 贪心策略) 隐含在 `max` 操作中，用于更新 Q 值。
    *   能够学习最优策略，即使行为策略不是最优的。
    *   在 CliffWalking 例子中，Q-Learning 倾向于学习贴近悬崖的“最优”（最短）路径，因为它直接估计最优价值，不受探索性动作的直接影响（只在选择执行动作时受影响）。
    *   Off-Policy 特性使其能利用历史数据。

今天我们将讨论如何将 Q-Learning (或类似思想) 应用于简化的商业问题，并进行中期复习。

# 案例模拟/讨论：简单动态定价

让我们考虑一个非常简化的动态定价问题，并尝试用 Q-Learning 的思路来建模和思考。

**场景:** 假设我们销售一种**单一商品**（例如，一种特定型号的打印机），库存有限。我们需要在**有限的时间段**内（例如，一周，每天可以调整一次价格）决定**每天的售价**，以最大化总销售收入。

## MDP 定义

1.  **状态 (State, S):** 如何描述与定价决策相关的环境状况？
    *   **核心要素:**
        *   `剩余时间 (t)`: 距离销售结束还有多少天 (e.g., 7, 6, ..., 1)。
        *   `当前库存 (k)`: 还剩多少台打印机 (e.g., 0, 1, ..., MaxInventory)。
    *   **可能的扩展 (增加状态复杂度):**
        *   `近期需求信号`: 过去一/两天的销售量？竞争对手的价格（如果可知）？是否有促销活动？
        *   `市场状态`: 宏观经济指标？季节性因素？
    *   **简化:** 为了便于讨论，我们先只考虑 `S = (剩余时间 t, 当前库存 k)`。这是一个离散的状态空间。

2.  **动作 (Action, A):** 我们可以采取哪些定价动作？
    *   **离散化:** 设定几个离散的价格点。
        *   例如: A = {低价 P_low, 中价 P_mid, 高价 P_high}
    *   **连续化:** (更复杂，需要函数逼近，我们后面会讲) 允许价格在一定范围内连续取值。
    *   **简化:** 我们使用离散动作空间 A = {P_low, P_mid, P_high}。

3.  **奖励 (Reward, R):** 如何衡量一个定价动作的好坏？
    *   **最直接:** 当天的**销售收入**。
        *   R(s, a) = 当天售价 * 当天销量
    *   **考虑成本:** (销售收入) - (销售成本) - (可能的库存持有成本？)。
    *   **考虑长期影响:** (复杂) 是否需要考虑低价对品牌形象的损害？高价导致客户流失？
    *   **简化:** 我们使用当天的销售收入作为即时奖励 R。

4.  **转移概率 (Transition Probability, P):** P(s' | s, a) = P((t', k') | (t, k), p)
    *   **时间转移:** t' = t - 1 (确定性)。
    *   **库存转移:** k' = k - 当天销量。这是**不确定**的部分，因为销量取决于价格 p 和随机的市场需求。
        *   **需求模型:** 我们需要一个（简化的）需求模型来表示不同价格下的预期销量（以及销量的随机性）。例如：
            *   `Demand(P_low) ~ Poisson(λ_low)`
            *   `Demand(P_mid) ~ Poisson(λ_mid)`
            *   `Demand(P_high) ~ Poisson(λ_high)`
            *   其中 λ_low > λ_mid > λ_high。实际销量 = min(模拟出的需求, 当前库存 k)。
    *   **无模型假设:** 在 Q-Learning 中，我们**不需要知道**这个精确的需求模型 (P)。我们只需要能够与环境（或模拟器）交互，执行动作 a (定价 p)，然后观察到奖励 R (当天收入) 和下一个状态 s' ((t-1, k - 实际销量))。

5.  **折扣因子 (γ):**
    *   如果只关心本周的总收入，且任务有明确终点（时间结束），可以使用 γ = 1。
    *   如果考虑稍微长远的影响或希望有更好的数学性质，可以使用 γ 略小于 1 (e.g., 0.99)。
    *   **简化:** 我们使用 γ = 1。

## Q-Learning 应用思路

1.  **初始化 Q 表:** 创建一个 Q 表，维度为 `(时间 t, 库存 k, 价格 p)`。Q((t, k), p) 表示在剩余 t 天、库存为 k 时，设定价格 p 的预期未来总收入。所有 Q 值初始化为 0。
2.  **模拟回合 (Episode):**
    *   一个回合代表一个完整的销售周期（例如，从 t=7, k=InitialInventory 开始，直到 t=0 结束）。
    *   在每个状态 (t, k) 下：
        *   使用 ε-greedy 策略选择一个价格 p (动作 A)。
        *   模拟市场需求（根据我们假设的（但算法本身不知道的）需求模型），计算实际销量 `sales = min(demand, k)`。
        *   计算奖励 R = p * sales。
        *   得到下一个状态 s' = (t-1, k - sales)。
        *   **Q-Learning 更新:**
            *   `Q_next_max = max_{p'} Q((t-1, k-sales), p')` (如果 t-1=0，则 Q_next_max=0)
            *   `Q((t, k), p) ← Q((t, k), p) + α * [R + γ * Q_next_max - Q((t, k), p)]`
3.  **重复模拟:** 运行大量回合。
4.  **最终策略:** 训练完成后，最优策略就是在每个状态 (t, k) 下，选择使得 Q((t, k), p) 最大的那个价格 p。

## 讨论：设计选择的影响

*   **状态表示 (S):**
    *   如果状态过于简化（只包含时间和库存），可能无法捕捉重要的市场动态（如竞争对手降价），导致学到的策略次优。
    *   如果状态过于复杂（包含太多信息），会导致状态空间爆炸，Q 表变得巨大，学习需要非常多的数据和时间（维度灾难 Curse of Dimensionality）。
*   **动作空间 (A):**
    *   离散价格点太少，可能无法找到真正的最优价格。
    *   离散价格点太多，也会增大 Q 表，减慢学习。
*   **奖励函数 (R):**
    *   只关注短期收入可能导致“杀鸡取卵”的行为（例如，最后一天疯狂降价清仓，损害品牌）。
    *   设计能够反映长期价值（如客户满意度、品牌形象、重复购买率）的奖励函数非常困难，是 RL 应用的关键挑战（Reward Engineering）。
*   **探索率 (ε):**
    *   需要足够的探索来尝试不同的价格组合，尤其是在早期。
    *   ε 太大会导致收入损失，太小则可能错过最优价格。ε 衰减通常是必要的。
*   **学习率 (α):**
    *   控制学习速度和稳定性。

## 局限性分析

*   **简化的需求模型:** 现实世界的需求受多种因素影响，很难用简单的概率分布描述。
*   **状态空间大小:** 即使只考虑时间和库存，如果时间长、库存量大，状态空间也会很大。对于更复杂的商业问题，表格型 Q-Learning (Tabular Q-Learning) 很快会变得不可行。
*   **非平稳环境 (Non-Stationary):** 市场需求、竞争对手行为可能随时间变化，这意味着环境的 P 和 R 不是固定的，违反了标准 MDP 的假设。需要更高级的 RL 技术来处理。
*   **样本效率 (Sample Efficiency):** 表格型 Q-Learning 通常需要大量的交互数据才能学到好的策略，在真实商业环境中可能成本过高。
*   **多智能体问题 (Multi-Agent):** 如果有竞争对手也在使用智能定价，问题就变成了更复杂的多智能体 RL 问题。

::: {.callout-note title="通往深度强化学习"}
当状态空间或动作空间变得巨大或连续时，我们无法再使用表格来存储 Q(s, a)。这时就需要使用**函数逼近 (Function Approximation)**，特别是**深度神经网络**，来近似 Q 函数。这就是**深度 Q 网络 (Deep Q-Network, DQN)** 等深度强化学习方法的基础，我们将在下一部分学习。
:::

# 中期复习 (Midterm Review)

本学期前半部分，我们围绕着如何让智能体在不确定的环境中做出最优的序贯决策进行了学习。核心概念回顾：

1.  **强化学习问题框架:**
    *   智能体 (Agent), 环境 (Environment), 状态 (S), 动作 (A), 奖励 (R)
    *   策略 (π), 价值函数 (V, Q), 模型 (P, R)
    *   回报 (Return) G_t, 折扣因子 (γ)
    *   探索 (Exploration) vs. 利用 (Exploitation)

2.  **马尔可夫决策过程 (MDP):**
    *   形式化定义 (S, A, P, R, γ)
    *   马尔可夫性质 (“未来只取决于现在”)
    *   商业场景的 MDP 建模 (状态、动作、奖励设计)

3.  **Bellman 方程:**
    *   **Bellman 期望方程 (用于策略评估):**
        *   Vπ(s) = E_π [R_{t+1} + γ Vπ(S_{t+1}) | S_t=s]
        *   Qπ(s, a) = E_π [R_{t+1} + γ Qπ(S_{t+1}, A_{t+1}) | S_t=s, A_t=a]
        *   描述了给定策略 π 下价值函数满足的递归关系。
    *   **Bellman 最优方程 (用于描述最优价值):**
        *   V*(s) = max_a E [R_{t+1} + γ V*(S_{t+1}) | S_t=s, A_t=a]
        *   Q*(s, a) = E [R_{t+1} + γ max_{a'} Q*(S_{t+1}, a') | S_t=s, A_t=a]
        *   描述了最优价值函数 V\* 和 Q\* 满足的条件，隐含了最大化操作。

4.  **无模型学习 (Model-Free Learning):** 当环境模型 P, R 未知时。
    *   **广义策略迭代 (GPI):** 策略评估 ↔ 策略改进。

5.  **蒙特卡洛 (MC) 方法:**
    *   **预测 (评估):** 通过大量完整回合，用平均回报 G_t 估计 Vπ 或 Qπ。
    *   首次访问 vs. 每次访问。
    *   **优点:** 无偏。
    *   **缺点:** 高方差，需等待回合结束，仅限回合制任务。

6.  **时序差分 (TD) 学习:**
    *   **TD(0) 预测:** 使用 TD 目标 R + γV(S') 进行自举更新 V(S)。
    *   **核心:** 自举 (Bootstrapping)，在线学习 (每步更新)。
    *   **优点:** 低方差，可用于持续性任务，通常收敛更快。
    *   **缺点:** 有偏 (依赖当前估计)，对初始值敏感。
    *   **TD 误差 δ:** R + γV(S') - V(S)

7.  **无模型控制算法:**
    *   **同策略 (On-Policy):** 学习的策略与行为策略相同。
        *   **SARSA:** 使用 (S, A, R, S', A') 更新 Q(S, A)。
        *   Q(S, A) ← Q(S, A) + α [R + γ Q(S', A') - Q(S, A)]
        *   学习的是包含探索行为（如 ε-greedy）的策略的价值。倾向于“安全”策略。
    *   **异策略 (Off-Policy):** 学习的策略与行为策略不同。
        *   **Q-Learning:** 使用 (S, A, R, S') 更新 Q(S, A)，直接学习最优 Q\*。
        *   Q(S, A) ← Q(S, A) + α [R + γ max_{a'} Q(S', a') - Q(S, A)]
        *   行为策略 (μ, e.g., ε-greedy) 用于探索，目标策略 (π, 贪心) 用于更新。倾向于“最优”（可能冒险）策略。可以利用历史数据。

## 关键区别与联系

*   **DP vs. Model-Free:** DP 需要模型，Model-Free 不需要。
*   **MC vs. TD:** MC 等待完整回报 (无偏, 高方差)，TD 使用自举 (有偏, 低方差)。
*   **Prediction vs. Control:** Prediction 评估给定策略，Control 寻找最优策略。
*   **On-Policy vs. Off-Policy:** On-Policy 学习正在执行的策略，Off-Policy 学习目标策略（可能与执行策略不同）。
*   **SARSA vs. Q-Learning:** 核心区别在于 TD 目标的计算方式 (Q(S', A') vs. max_{a'} Q(S', a'))，导致了同策略与异策略的差异以及学习到的策略偏好（安全 vs. 最优）。

## 中期测试准备

*   **形式:** 可能包含概念选择/填空/简答题，以及对简单模拟（如 Gridworld, CliffWalking）结果的分析和解释。
*   **重点:** 理解上述核心概念的定义、区别、联系、优缺点以及它们在算法（MC, TD(0), SARSA, Q-Learning）中的具体体现。能够解释算法的关键更新步骤。能够分析简单场景下的策略差异（如 SARSA vs. Q-Learning）。

::: {.callout-tip title="学习建议"}
*   回顾前几周的讲义和 Lab 代码。
*   尝试用自己的话解释每个核心概念。
*   思考不同算法之间的关键差异，以及为什么这些差异会导致不同的行为。
*   理解偏差-方差权衡在 MC 和 TD 中的体现。
*   理解同策略和异策略的根本区别及其影响。
:::

---

**下周预告:** 进入课程的第三部分：应对复杂性 - 函数逼近与深度强化学习。我们将探讨为什么需要函数逼近，以及如何使用神经网络来处理大规模或连续的状态/动作空间。