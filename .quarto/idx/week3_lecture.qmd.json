{"title":"Week 3: 最优决策与 Bellman 最优方程","markdown":{"yaml":{"title":"Week 3: 最优决策与 Bellman 最优方程"},"headingText":"回顾：MDP 与 Bellman 期望方程","containsRefs":false,"markdown":"\n\n\n上周我们学习了：\n\n*   **马尔可夫决策过程 (MDP):** $(S, A, P, R, \\gamma)$ 作为序贯决策问题的形式化框架。\n*   **马尔可夫性质:** 未来只取决于现在。\n*   **回报 (Return)** $G_t:$ 未来折扣奖励的总和。\n*   **策略 (Policy)** $\\pi:$ 状态到动作的映射。\n*   **价值函数** ($V_{\\pi}, Q_{\\pi}$): 衡量在策略 $\\pi$ 下状态或状态-动作对的长期价值。\n*   **Bellman 期望方程:** 建立了当前状态价值与后继状态价值之间的递归关系，用于**评估 (Evaluation)** 一个给定的策略 $\\pi$。\n\n$$\n\\begin{aligned}\nV_{\\pi}(s) &= \\sum_{a \\in A} \\pi(a|s) \\sum_{s' \\in S} P(s'|s,a) [R(s,a,s') + \\gamma V_{\\pi}(s')] \\\\\nQ_{\\pi}(s,a) &= \\sum_{s' \\in S} P(s'|s,a) [R(s,a,s') + \\gamma V_{\\pi}(s')]\n\\end{aligned}\n$$\n\n今天，我们的目标是找到**最优 (Optimal)** 的决策策略。\n\n# 最优价值函数 (Optimal Value Functions)\n\n在所有可能的策略中，至少存在一个策略比其他所有策略都好或者一样好。这个（些）策略称为**最优策略 (Optimal Policy)**，记作 $\\pi^*$。\n\n::: {.callout-important title=\"一定存在最优策略吗？\" collapse=\"true\"}\n是的，在有限 MDP 中，至少存在一个最优策略。这是因为：\n\n1. **有限性保证**：状态空间 $S$ 和动作空间 $A$ 都是有限的，策略空间也是有限的。\n2. **价值函数有界**：由于折扣因子 $\\gamma < 1$，价值函数 $V_{\\pi}(s)$ 对于任何策略 $\\pi$ 都是有界的。\n3. **存在性定理**：根据 MDP 理论，在有限 MDP 中，存在至少一个确定性策略 $\\pi^*$，使得对于所有状态 $s \\in S$，$V_{\\pi^*}(s) \\geq V_{\\pi}(s)$ 对所有其他策略 $\\pi$ 成立。\n\n需要注意的是：\n\n* 可能存在多个最优策略，但它们都共享相同的最优价值函数 $V^*$ 和 $Q^*$。\n* 在无限 MDP 中，最优策略的存在性需要额外的条件保证。\n\n**示例 1：库存管理**\n\n* 状态空间 S：当前库存水平（离散或连续）\n* 动作空间 A：订购数量（离散或连续）\n* 奖励 R：销售收入 - 订购成本 - 库存持有成本 - 缺货惩罚\n* 最优策略 π*：在每种库存水平下选择最优的订购数量，以最大化长期利润\n* V*(s)：在库存水平 s 下，采用最优策略所能获得的最大预期利润\n* Q*(s,a)：在库存水平 s 下，采取订购数量 a 后继续采用最优策略所能获得的最大预期利润\n* **存在最优策略的原因：**\n  - 状态空间和动作空间都是有限的（即使连续，在实际应用中也会离散化处理）\n  - 奖励函数有界（销售收入和成本都是有限的）\n  - 折扣因子 γ < 1 保证了长期利润的收敛性\n\n**示例 2：广告投放**\n\n* 状态空间 S：用户特征（如年龄、性别、浏览历史）\n* 动作空间 A：投放的广告类型\n* 奖励 R：用户点击广告带来的收入\n* 最优策略 π*：针对不同用户特征选择最优的广告类型，以最大化长期点击收入\n* V*(s)：对于具有特征 s 的用户，采用最优策略所能获得的最大预期收入\n* Q*(s,a)：对于具有特征 s 的用户，投放广告类型 a 后继续采用最优策略所能获得的最大预期收入\n* **存在最优策略的原因：**\n  - 用户特征和广告类型都是有限的\n  - 每次点击带来的收入是有限的\n  - 折扣因子 γ < 1 保证了长期收入的收敛性\n  - 用户行为模式相对稳定，满足马尔可夫性质\n\n**示例 3：机器人路径规划**\n\n* 状态空间 S：机器人的当前位置\n* 动作空间 A：可移动的方向（上、下、左、右）\n* 奖励 R：到达目标位置获得正奖励，撞墙获得负奖励\n* 最优策略 π*：在每个位置选择最优的移动方向，以最快到达目标\n* V*(s)：在位置 s 下，采用最优策略所能获得的最大预期奖励\n* Q*(s,a)：在位置 s 下，采取动作 a 后继续采用最优策略所能获得的最大预期奖励\n* **存在最优策略的原因：**\n  - 地图大小有限，位置状态是有限的\n  - 动作空间是离散且有限的\n  - 奖励函数有界（正负奖励都是有限的）\n  - 环境动态是确定性的，满足马尔可夫性质\n\n:::\n\n::: {.callout-warning title=\"不存在最优策略的情况\" collapse=\"true\"}\n在某些情况下，MDP 可能不存在最优策略，常见原因包括：\n\n1. **无限状态/动作空间且无界奖励**\n   * 当状态空间或动作空间是无限的，且奖励函数无界时，价值函数可能发散，导致不存在最优策略。\n   * 示例：连续状态和动作空间中的某些控制问题，如果奖励随状态/动作无限增长。\n\n2. **部分可观测性 (POMDP)**\n   * 在部分可观测马尔可夫决策过程中，智能体无法直接观察完整状态，可能导致不存在确定性的最优策略。\n   * 示例：机器人导航中，传感器只能提供部分环境信息。\n\n3. **非平稳环境**\n   * 当环境动态（转移概率或奖励函数）随时间变化时，可能不存在固定的最优策略。\n   * 示例：金融市场中的交易策略，市场条件不断变化。\n\n4. **多目标冲突**\n   * 当存在多个相互冲突的目标时，可能不存在单一的最优策略。\n   * 示例：同时优化利润和客户满意度的商业决策。\n\n5. **不可终止的 MDP**\n   * 在某些无限期 MDP 中，如果折扣因子 γ=1，价值函数可能发散。\n   * 示例：某些持续进行的控制任务，没有明确的终止状态。\n\n6. **不满足马尔可夫性质**\n   * 当当前状态不能完全捕获历史信息时，MDP 假设不成立。\n   * 示例：某些需要记忆历史状态才能做出最优决策的场景。\n:::\n\n::: {.callout-tip title=\"思考：围棋是否存在最优策略？\" collapse=\"true\"}\n围棋作为一种完全信息博弈，理论上存在最优策略，但实际中难以实现：\n\n1. **理论层面：**\n   * 围棋是有限状态、有限动作的完全信息博弈\n   * 根据Zermelo定理，存在确定性的最优策略\n   * 先手或后手必有一方有必胜策略（或双方都有保证和局的策略）\n\n2. **实践层面：**\n   * 状态空间极其庞大（约 10^170 种可能局面）\n   * 无法通过穷举法找到最优策略\n   * 即使使用强化学习（如 AlphaGo），也只能逼近最优策略\n\n3. **现实意义：**\n   * 当前 AI 水平已远超人类，但尚未达到理论最优\n   * 证明最优策略的存在性 ≠ 能够实际找到它\n   * 在可预见的未来，围棋仍将是一个极具挑战性的问题\n\n**启示：**\n\n* 理论最优与实际可行之间存在巨大鸿沟\n* 在复杂商业决策中，追求\"足够好\"的策略往往比寻找理论最优更实际\n* 强化学习等 AI 方法可以帮助我们在复杂问题中逼近最优解\n:::\n\n::: {.callout-tip title=\"哪些棋类游戏找到了最优策略？\" collapse=\"true\"}\n虽然大多数棋类游戏过于复杂而无法找到实际的最优策略，但一些简单的棋类游戏已经被完全解决：\n\n1. **井字棋 (Tic-Tac-Toe)**\n   * 已被完全解决，最优策略下双方必和\n   * 先手如果完美执行策略，永远不会输\n   * 后手如果完美执行策略，至少可以保证和局\n\n2. **五子棋 (Gomoku)**\n   * 在15x15棋盘上，先手有必胜策略\n   * 1993年由Victor Allis证明 [Allis, 1994]\n   * 但实际找到具体的最优策略仍然非常困难\n\n3. **国际象棋残局 (Chess Endgames)**\n   * 某些简单的残局（如王对王+兵）已被完全解决\n   * 通过穷举法建立了残局数据库 [Thompson, 1986]\n   * 但完整国际象棋的最优策略尚未找到\n\n4. **跳棋 (Checkers)**\n   * 2007年被完全解决\n   * 由Jonathan Schaeffer团队通过穷举法证明 [Schaeffer et al., 2007]\n   * 最优策略下双方必和\n\n5. **四子棋 (Connect Four)**\n   * 1988年被完全解决\n   * 先手有必胜策略\n   * 通过穷举法证明 [Allis, 1988]\n\n**主要参考文献：**\n\n- Allis, L. V. (1994). Searching for solutions in games and artificial intelligence. PhD thesis, University of Limburg, Maastricht.\n- Thompson, K. (1986). Retrograde analysis of certain endgames. ICCA Journal, 9(3), 131-139.\n- Schaeffer, J., Burch, N., Björnsson, Y., Kishimoto, A., Müller, M., Lake, R., ... & Sutphen, S. (2007). Checkers is solved. Science, 317(5844), 1518-1522.\n- Allis, L. V. (1988). A knowledge-based approach of connect-four. Master's thesis, Vrije Universiteit, Amsterdam.\n\n**启示：**\n\n* 简单棋类游戏可以通过穷举法找到最优策略\n* 随着游戏复杂度增加，找到最优策略变得极其困难\n* 即使理论上存在最优策略，实际找到它可能需要巨大的计算资源\n* 在复杂游戏中，AI方法（如强化学习）可以帮助我们逼近最优策略\n:::\n\n\n\n最优策略对应的价值函数称为**最优价值函数 (Optimal Value Functions)**。\n\n*   **最优状态值函数 (Optimal State-Value Function, $V^*$):**\n    *   定义: $V^*(s) = \\max_{\\pi} V_{\\pi}(s)$ for all $s \\in S$\n    *   含义: 对于状态 $s$，在所有可能的策略中能够获得的最大预期回报。它代表了状态 $s$ 的**真正内在价值**。\n\n*   **最优动作值函数 (Optimal Action-Value Function, $Q^*$):**\n    *   定义: $Q^*(s, a) = \\max_{\\pi} Q_{\\pi}(s, a)$ for all $s \\in S, a \\in A$\n    *   含义: 对于状态 $s$ 和动作 $a$，在所有可能的策略下，先执行动作 $a$ 然后继续遵循该策略所能获得的最大预期回报。它代表了在状态 $s$ 下采取动作 $a$ 的**真正最优价值**。\n\n::: {.callout-important title=\"Q* 的重要性\"}\n如果我们知道了 $Q^*(s, a)$，那么找到最优策略 $\\pi^*$ 就非常简单：在任何状态 $s$，只需选择那个使得 $Q^*(s, a)$ 最大的动作 $a$ 即可。\n$\\pi^*(s) = \\arg\\max_a Q^*(s, a)$\n这是一个**贪心策略 (Greedy Policy)**。相对于最优动作值函数 $Q^*$ 采取贪心策略，本身就是最优策略。\n\n如何理解这个结论在随机性环境中的适用性：\n\n1. $Q^*(s, a)$ 已经包含了状态转移的不确定性，它表示的是在状态 $s$ 采取动作 $a$ 后的**期望**累积回报\n2. 在随机性环境中，虽然每次执行相同动作可能导致不同的结果，但 $Q^*(s, a)$ 已经对这些可能结果进行了加权平均\n3. 因此，选择最大 $Q^*(s, a)$ 的动作是在长期期望意义下的最优选择，即使单次执行可能不是最优结果\n4. 这种策略在多次执行中会表现出最优性，因为它最大化的是期望回报，而不是单次回报\n:::\n\n::: {.callout-note title=\"V* 与 Q* 的关系\"}\n$V^*$ 和 $Q^*$ 之间有以下重要关系：\n\n* $V^*(s) = \\max_a Q^*(s, a)$  \n  - 这是根据最优价值函数的定义直接得到的\n  - 表示一个状态的最优价值等于在该状态下采取最优动作的价值\n\n* $Q^*(s, a) = \\sum_{s' \\in S} P(s' | s, a) [R(s, a, s') + \\gamma \\max_{a'} Q^*(s', a')]$\n  - 这是 Bellman 最优方程的直接结果\n  - 表示在状态 s 采取动作 a 的最优价值等于：\n    1. 即时奖励 R(s, a, s')\n    2. 加上所有可能的后继状态采取最优动作的价值的折扣期望\n:::\n\n# Bellman 最优方程 (Bellman Optimality Equation)\n\nBellman 最优方程描述了最优价值函数 $V^*$ 和 $Q^*$ 必须满足的条件。它与 Bellman 期望方程不同，期望方程是针对某个特定策略 $\\pi$ 的，而最优方程是针对最优策略 $\\pi^*$ 的，并且隐含了**最大化**操作。\n\n**$V^*$ 的 Bellman 最优方程:**\n\n$$\n\\begin{align}\nV^*(s) &= \\max_a E [R_{t+1} + \\gamma V^*(S_{t+1}) | S_t=s, A_t=a] \\\\\n      &= \\max_a \\sum_{s' \\in S} P(s' | s, a) [R(s, a, s') + \\gamma V^*(s')]\n\\end{align}\n$$\n\n**直观解读:**\n\n一个状态 $s$ 的**最优价值 ($V^*(s)$)** 等于：选择那个能够最大化 **(即时奖励 + 未来最优预期价值)** 的动作 $a$ 所带来的期望回报。\n这个 $\\max_a$ 体现了最优策略在每个状态下都会选择最好的动作。\n\n**$Q^*$ 的 Bellman 最优方程:**\n\n$$\n\\begin{align}\nQ^*(s, a) &= E [R_{t+1} + \\gamma \\max_{a'} Q^*(S_{t+1}, a') | S_t=s, A_t=a] \\\\\n         &= \\sum_{s' \\in S} P(s' | s, a) [R(s, a, s') + \\gamma \\max_{a'} Q^*(s', a')] \\\\\n         &= \\sum_{s' \\in S} P(s' | s, a) [R(s, a, s') + \\gamma V^*(s')] \n\\end{align}\n$$\n         \n         \n(利用 V* 和 Q* 的关系)\n\n**直观解读:**\n\n在状态 $s$ 采取动作 $a$ 的**最优价值 ($Q^*(s, a)$)** 等于：\n\n1.  获得即时奖励 $R(s, a, s')$。\n2.  转移到后继状态 $s'$。\n3.  在后继状态 $s'$，采取**最优**的下一个动作 $a'$ (即 $\\max_{a'} Q^*(s', a')$，这等价于 $V^*(s')$)。\n4.  将即时奖励和后继状态的最优折扣价值加起来，并对所有可能的后继状态 $s'$ 求期望。\n\n::: {.callout-note title=\"期望方程 vs. 最优方程\"}\n*   **Bellman 期望方程:** 用于**评估**一个给定的策略 $\\pi$，计算 $V_{\\pi}$ 或 $Q_{\\pi}$。它是一个线性方程组（如果状态动作空间有限）。\n*   **Bellman 最优方程:** 用于描述**最优**价值函数 $V^*$ 或 $Q^*$ 满足的条件。由于 `max` 操作的存在，它是一个非线性方程组。求解这个方程组就能得到最优价值函数，进而得到最优策略。\n:::\n\n## 最优方程的作用\n\nBellman 最优方程在强化学习中扮演着至关重要的角色，主要体现在以下几个方面：\n\n1. **理论基石:** 为强化学习算法提供了坚实的理论基础，证明了最优价值函数和最优策略的存在性。\n\n2. **算法设计指导:** 许多经典强化学习算法（如值迭代、策略迭代、Q-learning）都是基于 Bellman 最优方程设计的。\n\n3. **最优策略求解:** 通过求解 Bellman 最优方程，可以直接得到最优价值函数 $V^*$ 和 $Q^*$，进而推导出最优策略 $\\pi^*$。\n\n4. **收敛性保证:** 在满足一定条件下，基于 Bellman 最优方程的算法能够保证收敛到最优解。\n\n5. **价值函数更新:** 为价值函数的更新提供了明确的数学公式，指导智能体如何根据经验改进其价值估计。\n\n6. **策略改进:** 通过比较当前策略与最优价值函数，可以系统地改进策略，使其逐步接近最优。\n\n7. **理论分析工具:** 可用于分析强化学习算法的收敛速度、样本复杂度等理论性质。\n\n8. **实际应用指导:** 为实际应用中的策略优化提供了明确的方向，帮助设计更有效的学习算法。\n\n::: {.callout-note title=\"最优方程 vs. 期望方程\"}\n* **最优方程**用于寻找最优策略，包含最大化操作，是非线性方程\n* **期望方程**用于评估特定策略，是线性方程\n* 两者都基于 Bellman 方程，但目标不同\n:::\n\n## 实际应用中的选择\n\n在实际应用中，我们通常需要根据具体问题和计算资源在期望方程和最优方程之间做出选择：\n\n1. **期望方程的应用场景:**\n   * 当我们需要评估某个特定策略的性能时\n   * 在策略迭代算法中，用于策略评估阶段\n   * 当状态空间较大时，作为近似求解的起点\n   * 在在线学习中，用于实时更新策略价值\n\n2. **最优方程的应用场景:**\n   * 当我们的目标是找到最优策略时\n   * 在值迭代算法中，直接用于寻找最优价值函数\n   * 在Q-learning等off-policy算法中，用于更新最优动作值函数\n   * 当计算资源充足时，用于精确求解\n\n3. **实际考虑因素:**\n   * **计算复杂度:** 最优方程由于包含max操作，通常比期望方程更难求解\n   * **状态空间大小:** 对于大规模问题，通常需要结合近似方法\n   * **收敛速度:** 期望方程有时可以更快收敛，但可能陷入次优解\n   * **应用需求:** 如果只需要一个可行的好策略，期望方程可能就足够了\n\n::: {.callout-tip title=\"实际应用建议\"}\n* 对于小规模问题，可以直接求解最优方程\n* 对于大规模问题，建议采用近似方法或结合使用两种方程\n* 在策略迭代中交替使用两种方程往往能取得较好效果\n* 考虑使用函数逼近等方法来降低计算复杂度\n:::\n\n4. **折中方案:**\n   * 使用期望方程作为初始近似，逐步向最优方程过渡\n   * 在策略迭代中交替使用期望方程和最优方程\n   * 采用近似方法（如函数逼近）来降低最优方程的求解难度\n\n::: {.callout-warning title=\"注意事项\"}\n* 虽然 Bellman 最优方程在理论上非常强大，但在实际应用中，由于状态空间可能非常大或连续，直接求解往往不可行\n* 奖励函数的设计会显著影响最优策略的质量\n* 在实际应用中，通常需要在最优性和计算效率之间进行权衡\n:::\n\n\n## 理解“最优”的含义\n\n*   **最大化预期累积折扣回报:** 最优策略旨在最大化从任何状态开始的长期期望回报 $G_t$。\n*   **不一定是单步最优:** 最优策略有时可能需要采取一个即时奖励较低的动作，以便进入一个更有利的未来状态，从而获得更高的长期回报（“牺牲小我，完成大我”）。\n*   **可能存在多个最优策略:** 对于同一个 MDP，可能存在多个不同的策略都能达到相同的最优价值函数 $V^*$ 和 $Q^*$。\n*   **依赖于 MDP 定义:** 最优性是相对于给定的状态空间 $S$、动作空间 $A$、转移概率 $P$、奖励函数 $R$ 和折扣因子 $\\gamma$ 而言的。改变其中任何一个，最优策略和价值函数都可能改变。\n\n::: {.callout-warning title=\"奖励设计的关键性\"}\n奖励函数 $R$ 直接定义了智能体的目标。如果奖励函数设计不当（例如，只奖励短期行为而忽略长期后果），即使找到了该奖励函数下的“最优”策略，也可能无法实现真正的商业目标。设计一个能够准确反映长期商业价值的奖励函数是 RL 应用中的核心挑战。\n:::\n\n# Lab 1 (热身): 熟悉 Gym/Gymnasium 环境\n\n本周的实验课旨在让大家动手实践，熟悉强化学习实验的基本流程和工具。\n\n## 目标\n\n1.  **安装并配置 Gym/Gymnasium 环境:** 确保大家都能成功运行基本的 Gym 脚本。\n2.  **理解环境交互循环:** 掌握 `reset`, `step`, `render` 等核心函数的使用。\n3.  **观察 $S, A, R:$ 运行一个简单的随机策略智能体，观察状态、动作、奖励的变化。\n4.  **概念练习:** 将一个简单的商业场景映射到 Gym 环境的要素。\n\n## 步骤\n\n1.  **环境安装检查:**\n    *   确保你已经按照上周讲义的指导，在虚拟环境中安装了 `gymnasium` 和 `gymnasium[classic_control]`。\n    *   尝试运行上周提供的 CartPole 随机智能体示例代码，确保能看到可视化窗口并且代码正常运行。\n\n2.  **运行随机智能体:**\n    *   仔细阅读 CartPole 示例代码。\n    *   尝试修改代码：\n        *   改变 `range(1000)` 中的数字，看看一个回合能持续多少步。\n        *   去掉 `time.sleep(1)`，观察运行速度。\n        *   尝试另一个简单的环境，如 \"MountainCar-v0\" 或 \"Acrobot-v1\" (如果已安装 `box2d-py`，可以尝试 \"LunarLander-v2\")。观察它们的状态空间、动作空间和奖励结构有何不同。\n        ```python\n        import gymnasium as gym\n        # env = gym.make(\"MountainCar-v0\", render_mode=\"human\")\n        # env = gym.make(\"Acrobot-v1\", render_mode=\"human\")\n        # env = gym.make(\"LunarLander-v2\", render_mode=\"human\") # 需要 box2d\n        # ... (其余代码类似 CartPole)\n        ```\n    *   **思考:** 随机策略在这些环境中的表现如何？为什么？\n\n3.  **理解环境交互循环:**\n    *   在 `step` 函数前后打印 `observation`, `action`, `reward`, `terminated`, `truncated` 的值。\n    *   理解 `terminated` 和 `truncated` 的区别：\n        *   `terminated`: 环境达到了自然的终点（成功或失败）。\n        *   `truncated`: 环境因为外部限制（如时间步数）而提前结束。\n    *   查看 `env.observation_space` 和 `env.action_space`，了解状态和动作的类型与范围。\n\n4.  **练习：定义简单商业场景为 Gym 环境 (概念或简化代码)**\n\n    选择一个简单的商业场景，例如：\n\n    *   **单商品库存管理:**\n        *   目标：决定每天订购多少商品以最大化利润。\n        *   **状态 ($S$):** 当前库存水平 (离散或连续？)。可以简化为几个等级，如 [低, 中, 高]。\n        *   **动作 ($A$):** 订购数量 (离散？)。可以简化为 [不订购, 订购少量, 订购大量]。\n        *   **奖励 ($R$):** (销售收入) - (订购成本) - (库存持有成本) - (缺货惩罚)。如何量化这些值？\n        *   **转移概率 ($P$):** 假设已知每天的需求概率分布。根据当前库存、订购量和实际需求，计算下一天的库存水平。\n        *   **折扣因子 ($\\gamma$):** 如何选择？取决于关注短期利润还是长期稳定？\n\n    *   **简单广告投放:**\n        *   目标：决定在哪个渠道投放广告以最大化点击率或转化率。\n        *   **状态 ($S$):** 可以简化为当前日期是工作日还是周末？或者用户的某个简单分类？\n        *   **动作 ($A$):** 选择渠道 A 或渠道 B。\n        *   **奖励 ($R$):** 该渠道带来的点击次数或转化价值。\n        *   **转移概率 ($P$):** 状态转移可能很简单（如第二天），或者依赖于用户行为。\n        *   **折扣因子 ($\\gamma$):** 如果只关心单次投放效果，$\\gamma$ 可以为 0。如果考虑长期影响，$\\gamma > 0$。\n\n    **任务:**\n    *   选择一个场景。\n    *   **概念设计:** 清晰地定义 $S, A, R, P$ (可以描述性地说明转移逻辑), $\\gamma$。\n    *   **(可选) 简化代码框架:** 尝试编写一个 Python 类，模仿 Gym 环境的接口 (`__init__`, `reset`, `step`)。不需要完全实现复杂的逻辑，重点是定义接口和数据结构。\n\n    ```python\n    import gymnasium as gym\n    from gymnasium import spaces\n    import numpy as np\n\n    class SimpleInventoryEnv(gym.Env):\n        metadata = {'render_modes': [], 'render_fps': 4} # 元数据\n\n        def __init__(self, max_inventory=20, max_order=5, demand_dist=[0.1, 0.6, 0.3]):\n            super().__init__() # 调用父类构造函数\n\n            self.max_inventory = max_inventory\n            self.max_order = max_order\n            self.demand_dist = demand_dist # 假设需求是 0, 1, 2 的概率\n            self.possible_demands = np.arange(len(demand_dist))\n\n            # 定义状态空间：库存水平 (0 到 max_inventory)\n            self.observation_space = spaces.Discrete(max_inventory + 1)\n\n            # 定义动作空间：订购数量 (0 到 max_order)\n            self.action_space = spaces.Discrete(max_order + 1)\n\n            # 内部状态变量\n            self._current_inventory = 0\n\n        def _get_obs(self):\n            return self._current_inventory\n\n        def _get_info(self):\n            # 可以返回一些辅助信息，例如实际需求量\n            # return {\"demand\": self._last_demand}\n            return {}\n\n        def reset(self, seed=None, options=None):\n            super().reset(seed=seed) # 处理随机种子\n\n            # 重置库存为 0 (或其他初始值)\n            self._current_inventory = 0\n            observation = self._get_obs()\n            info = self._get_info()\n            return observation, info\n\n        def step(self, action):\n            # 1. 获取订购量 (动作)\n            order_quantity = action\n\n            # 2. 计算订购后的库存 (假设立即到货)\n            inventory_after_order = self._current_inventory + order_quantity\n            # 限制最大库存\n            inventory_after_order = min(inventory_after_order, self.max_inventory)\n\n            # 3. 模拟随机需求\n            demand = self.np_random.choice(self.possible_demands, p=self.demand_dist)\n            self._last_demand = demand # 记录需求，可选\n\n            # 4. 计算满足的需求 (销售量)\n            sales = min(inventory_after_order, demand)\n\n            # 5. 计算下一时刻的库存\n            self._current_inventory = inventory_after_order - sales\n\n            # 6. 计算奖励 (简化示例)\n            # 假设：售价=10, 订购成本=3, 持有成本=1, 缺货惩罚=2\n            revenue = sales * 10\n            order_cost = order_quantity * 3\n            holding_cost = self._current_inventory * 1 # 期末库存持有成本\n            shortage_cost = max(0, demand - inventory_after_order) * 2 # 缺货成本\n\n            reward = revenue - order_cost - holding_cost - shortage_cost\n\n            # 7. 确定是否结束 (在这个简单模型中，可以假设永不结束)\n            terminated = False\n            truncated = False # 也可以设置最大步数\n\n            observation = self._get_obs()\n            info = self._get_info()\n\n            return observation, reward, terminated, truncated, info\n\n        def render(self):\n            # 这个简单环境不需要可视化\n            pass\n\n        def close(self):\n            pass\n\n    # --- 如何使用 ---\n    # env = SimpleInventoryEnv()\n    # observation, info = env.reset()\n    # for _ in range(100):\n    #    action = env.action_space.sample() # 随机选择订购量\n    #    observation, reward, terminated, truncated, info = env.step(action)\n    #    print(f\"Inv: {observation}, Action: {action}, Reward: {reward}\")\n    #    if terminated or truncated:\n    #        break\n    # env.close()\n\n    ```\n\n## 提交要求\n\n*   确保你的 Python 环境可以运行 Gym/Gymnasium 示例。\n*   完成商业场景的概念设计 ($S, A, R, P, \\gamma$)。\n*   (可选) 提交你尝试编写的简化 Gym 环境代码框架。\n*   **思考:** 在你设计的商业场景中，马尔可夫性质是否容易满足？状态需要包含哪些信息才能更好地近似它？\n\n---\n\n**下周预告:** 开始学习无模型预测方法 - 蒙特卡洛 (Monte Carlo) 方法。","srcMarkdownNoYaml":"\n\n# 回顾：MDP 与 Bellman 期望方程\n\n上周我们学习了：\n\n*   **马尔可夫决策过程 (MDP):** $(S, A, P, R, \\gamma)$ 作为序贯决策问题的形式化框架。\n*   **马尔可夫性质:** 未来只取决于现在。\n*   **回报 (Return)** $G_t:$ 未来折扣奖励的总和。\n*   **策略 (Policy)** $\\pi:$ 状态到动作的映射。\n*   **价值函数** ($V_{\\pi}, Q_{\\pi}$): 衡量在策略 $\\pi$ 下状态或状态-动作对的长期价值。\n*   **Bellman 期望方程:** 建立了当前状态价值与后继状态价值之间的递归关系，用于**评估 (Evaluation)** 一个给定的策略 $\\pi$。\n\n$$\n\\begin{aligned}\nV_{\\pi}(s) &= \\sum_{a \\in A} \\pi(a|s) \\sum_{s' \\in S} P(s'|s,a) [R(s,a,s') + \\gamma V_{\\pi}(s')] \\\\\nQ_{\\pi}(s,a) &= \\sum_{s' \\in S} P(s'|s,a) [R(s,a,s') + \\gamma V_{\\pi}(s')]\n\\end{aligned}\n$$\n\n今天，我们的目标是找到**最优 (Optimal)** 的决策策略。\n\n# 最优价值函数 (Optimal Value Functions)\n\n在所有可能的策略中，至少存在一个策略比其他所有策略都好或者一样好。这个（些）策略称为**最优策略 (Optimal Policy)**，记作 $\\pi^*$。\n\n::: {.callout-important title=\"一定存在最优策略吗？\" collapse=\"true\"}\n是的，在有限 MDP 中，至少存在一个最优策略。这是因为：\n\n1. **有限性保证**：状态空间 $S$ 和动作空间 $A$ 都是有限的，策略空间也是有限的。\n2. **价值函数有界**：由于折扣因子 $\\gamma < 1$，价值函数 $V_{\\pi}(s)$ 对于任何策略 $\\pi$ 都是有界的。\n3. **存在性定理**：根据 MDP 理论，在有限 MDP 中，存在至少一个确定性策略 $\\pi^*$，使得对于所有状态 $s \\in S$，$V_{\\pi^*}(s) \\geq V_{\\pi}(s)$ 对所有其他策略 $\\pi$ 成立。\n\n需要注意的是：\n\n* 可能存在多个最优策略，但它们都共享相同的最优价值函数 $V^*$ 和 $Q^*$。\n* 在无限 MDP 中，最优策略的存在性需要额外的条件保证。\n\n**示例 1：库存管理**\n\n* 状态空间 S：当前库存水平（离散或连续）\n* 动作空间 A：订购数量（离散或连续）\n* 奖励 R：销售收入 - 订购成本 - 库存持有成本 - 缺货惩罚\n* 最优策略 π*：在每种库存水平下选择最优的订购数量，以最大化长期利润\n* V*(s)：在库存水平 s 下，采用最优策略所能获得的最大预期利润\n* Q*(s,a)：在库存水平 s 下，采取订购数量 a 后继续采用最优策略所能获得的最大预期利润\n* **存在最优策略的原因：**\n  - 状态空间和动作空间都是有限的（即使连续，在实际应用中也会离散化处理）\n  - 奖励函数有界（销售收入和成本都是有限的）\n  - 折扣因子 γ < 1 保证了长期利润的收敛性\n\n**示例 2：广告投放**\n\n* 状态空间 S：用户特征（如年龄、性别、浏览历史）\n* 动作空间 A：投放的广告类型\n* 奖励 R：用户点击广告带来的收入\n* 最优策略 π*：针对不同用户特征选择最优的广告类型，以最大化长期点击收入\n* V*(s)：对于具有特征 s 的用户，采用最优策略所能获得的最大预期收入\n* Q*(s,a)：对于具有特征 s 的用户，投放广告类型 a 后继续采用最优策略所能获得的最大预期收入\n* **存在最优策略的原因：**\n  - 用户特征和广告类型都是有限的\n  - 每次点击带来的收入是有限的\n  - 折扣因子 γ < 1 保证了长期收入的收敛性\n  - 用户行为模式相对稳定，满足马尔可夫性质\n\n**示例 3：机器人路径规划**\n\n* 状态空间 S：机器人的当前位置\n* 动作空间 A：可移动的方向（上、下、左、右）\n* 奖励 R：到达目标位置获得正奖励，撞墙获得负奖励\n* 最优策略 π*：在每个位置选择最优的移动方向，以最快到达目标\n* V*(s)：在位置 s 下，采用最优策略所能获得的最大预期奖励\n* Q*(s,a)：在位置 s 下，采取动作 a 后继续采用最优策略所能获得的最大预期奖励\n* **存在最优策略的原因：**\n  - 地图大小有限，位置状态是有限的\n  - 动作空间是离散且有限的\n  - 奖励函数有界（正负奖励都是有限的）\n  - 环境动态是确定性的，满足马尔可夫性质\n\n:::\n\n::: {.callout-warning title=\"不存在最优策略的情况\" collapse=\"true\"}\n在某些情况下，MDP 可能不存在最优策略，常见原因包括：\n\n1. **无限状态/动作空间且无界奖励**\n   * 当状态空间或动作空间是无限的，且奖励函数无界时，价值函数可能发散，导致不存在最优策略。\n   * 示例：连续状态和动作空间中的某些控制问题，如果奖励随状态/动作无限增长。\n\n2. **部分可观测性 (POMDP)**\n   * 在部分可观测马尔可夫决策过程中，智能体无法直接观察完整状态，可能导致不存在确定性的最优策略。\n   * 示例：机器人导航中，传感器只能提供部分环境信息。\n\n3. **非平稳环境**\n   * 当环境动态（转移概率或奖励函数）随时间变化时，可能不存在固定的最优策略。\n   * 示例：金融市场中的交易策略，市场条件不断变化。\n\n4. **多目标冲突**\n   * 当存在多个相互冲突的目标时，可能不存在单一的最优策略。\n   * 示例：同时优化利润和客户满意度的商业决策。\n\n5. **不可终止的 MDP**\n   * 在某些无限期 MDP 中，如果折扣因子 γ=1，价值函数可能发散。\n   * 示例：某些持续进行的控制任务，没有明确的终止状态。\n\n6. **不满足马尔可夫性质**\n   * 当当前状态不能完全捕获历史信息时，MDP 假设不成立。\n   * 示例：某些需要记忆历史状态才能做出最优决策的场景。\n:::\n\n::: {.callout-tip title=\"思考：围棋是否存在最优策略？\" collapse=\"true\"}\n围棋作为一种完全信息博弈，理论上存在最优策略，但实际中难以实现：\n\n1. **理论层面：**\n   * 围棋是有限状态、有限动作的完全信息博弈\n   * 根据Zermelo定理，存在确定性的最优策略\n   * 先手或后手必有一方有必胜策略（或双方都有保证和局的策略）\n\n2. **实践层面：**\n   * 状态空间极其庞大（约 10^170 种可能局面）\n   * 无法通过穷举法找到最优策略\n   * 即使使用强化学习（如 AlphaGo），也只能逼近最优策略\n\n3. **现实意义：**\n   * 当前 AI 水平已远超人类，但尚未达到理论最优\n   * 证明最优策略的存在性 ≠ 能够实际找到它\n   * 在可预见的未来，围棋仍将是一个极具挑战性的问题\n\n**启示：**\n\n* 理论最优与实际可行之间存在巨大鸿沟\n* 在复杂商业决策中，追求\"足够好\"的策略往往比寻找理论最优更实际\n* 强化学习等 AI 方法可以帮助我们在复杂问题中逼近最优解\n:::\n\n::: {.callout-tip title=\"哪些棋类游戏找到了最优策略？\" collapse=\"true\"}\n虽然大多数棋类游戏过于复杂而无法找到实际的最优策略，但一些简单的棋类游戏已经被完全解决：\n\n1. **井字棋 (Tic-Tac-Toe)**\n   * 已被完全解决，最优策略下双方必和\n   * 先手如果完美执行策略，永远不会输\n   * 后手如果完美执行策略，至少可以保证和局\n\n2. **五子棋 (Gomoku)**\n   * 在15x15棋盘上，先手有必胜策略\n   * 1993年由Victor Allis证明 [Allis, 1994]\n   * 但实际找到具体的最优策略仍然非常困难\n\n3. **国际象棋残局 (Chess Endgames)**\n   * 某些简单的残局（如王对王+兵）已被完全解决\n   * 通过穷举法建立了残局数据库 [Thompson, 1986]\n   * 但完整国际象棋的最优策略尚未找到\n\n4. **跳棋 (Checkers)**\n   * 2007年被完全解决\n   * 由Jonathan Schaeffer团队通过穷举法证明 [Schaeffer et al., 2007]\n   * 最优策略下双方必和\n\n5. **四子棋 (Connect Four)**\n   * 1988年被完全解决\n   * 先手有必胜策略\n   * 通过穷举法证明 [Allis, 1988]\n\n**主要参考文献：**\n\n- Allis, L. V. (1994). Searching for solutions in games and artificial intelligence. PhD thesis, University of Limburg, Maastricht.\n- Thompson, K. (1986). Retrograde analysis of certain endgames. ICCA Journal, 9(3), 131-139.\n- Schaeffer, J., Burch, N., Björnsson, Y., Kishimoto, A., Müller, M., Lake, R., ... & Sutphen, S. (2007). Checkers is solved. Science, 317(5844), 1518-1522.\n- Allis, L. V. (1988). A knowledge-based approach of connect-four. Master's thesis, Vrije Universiteit, Amsterdam.\n\n**启示：**\n\n* 简单棋类游戏可以通过穷举法找到最优策略\n* 随着游戏复杂度增加，找到最优策略变得极其困难\n* 即使理论上存在最优策略，实际找到它可能需要巨大的计算资源\n* 在复杂游戏中，AI方法（如强化学习）可以帮助我们逼近最优策略\n:::\n\n\n\n最优策略对应的价值函数称为**最优价值函数 (Optimal Value Functions)**。\n\n*   **最优状态值函数 (Optimal State-Value Function, $V^*$):**\n    *   定义: $V^*(s) = \\max_{\\pi} V_{\\pi}(s)$ for all $s \\in S$\n    *   含义: 对于状态 $s$，在所有可能的策略中能够获得的最大预期回报。它代表了状态 $s$ 的**真正内在价值**。\n\n*   **最优动作值函数 (Optimal Action-Value Function, $Q^*$):**\n    *   定义: $Q^*(s, a) = \\max_{\\pi} Q_{\\pi}(s, a)$ for all $s \\in S, a \\in A$\n    *   含义: 对于状态 $s$ 和动作 $a$，在所有可能的策略下，先执行动作 $a$ 然后继续遵循该策略所能获得的最大预期回报。它代表了在状态 $s$ 下采取动作 $a$ 的**真正最优价值**。\n\n::: {.callout-important title=\"Q* 的重要性\"}\n如果我们知道了 $Q^*(s, a)$，那么找到最优策略 $\\pi^*$ 就非常简单：在任何状态 $s$，只需选择那个使得 $Q^*(s, a)$ 最大的动作 $a$ 即可。\n$\\pi^*(s) = \\arg\\max_a Q^*(s, a)$\n这是一个**贪心策略 (Greedy Policy)**。相对于最优动作值函数 $Q^*$ 采取贪心策略，本身就是最优策略。\n\n如何理解这个结论在随机性环境中的适用性：\n\n1. $Q^*(s, a)$ 已经包含了状态转移的不确定性，它表示的是在状态 $s$ 采取动作 $a$ 后的**期望**累积回报\n2. 在随机性环境中，虽然每次执行相同动作可能导致不同的结果，但 $Q^*(s, a)$ 已经对这些可能结果进行了加权平均\n3. 因此，选择最大 $Q^*(s, a)$ 的动作是在长期期望意义下的最优选择，即使单次执行可能不是最优结果\n4. 这种策略在多次执行中会表现出最优性，因为它最大化的是期望回报，而不是单次回报\n:::\n\n::: {.callout-note title=\"V* 与 Q* 的关系\"}\n$V^*$ 和 $Q^*$ 之间有以下重要关系：\n\n* $V^*(s) = \\max_a Q^*(s, a)$  \n  - 这是根据最优价值函数的定义直接得到的\n  - 表示一个状态的最优价值等于在该状态下采取最优动作的价值\n\n* $Q^*(s, a) = \\sum_{s' \\in S} P(s' | s, a) [R(s, a, s') + \\gamma \\max_{a'} Q^*(s', a')]$\n  - 这是 Bellman 最优方程的直接结果\n  - 表示在状态 s 采取动作 a 的最优价值等于：\n    1. 即时奖励 R(s, a, s')\n    2. 加上所有可能的后继状态采取最优动作的价值的折扣期望\n:::\n\n# Bellman 最优方程 (Bellman Optimality Equation)\n\nBellman 最优方程描述了最优价值函数 $V^*$ 和 $Q^*$ 必须满足的条件。它与 Bellman 期望方程不同，期望方程是针对某个特定策略 $\\pi$ 的，而最优方程是针对最优策略 $\\pi^*$ 的，并且隐含了**最大化**操作。\n\n**$V^*$ 的 Bellman 最优方程:**\n\n$$\n\\begin{align}\nV^*(s) &= \\max_a E [R_{t+1} + \\gamma V^*(S_{t+1}) | S_t=s, A_t=a] \\\\\n      &= \\max_a \\sum_{s' \\in S} P(s' | s, a) [R(s, a, s') + \\gamma V^*(s')]\n\\end{align}\n$$\n\n**直观解读:**\n\n一个状态 $s$ 的**最优价值 ($V^*(s)$)** 等于：选择那个能够最大化 **(即时奖励 + 未来最优预期价值)** 的动作 $a$ 所带来的期望回报。\n这个 $\\max_a$ 体现了最优策略在每个状态下都会选择最好的动作。\n\n**$Q^*$ 的 Bellman 最优方程:**\n\n$$\n\\begin{align}\nQ^*(s, a) &= E [R_{t+1} + \\gamma \\max_{a'} Q^*(S_{t+1}, a') | S_t=s, A_t=a] \\\\\n         &= \\sum_{s' \\in S} P(s' | s, a) [R(s, a, s') + \\gamma \\max_{a'} Q^*(s', a')] \\\\\n         &= \\sum_{s' \\in S} P(s' | s, a) [R(s, a, s') + \\gamma V^*(s')] \n\\end{align}\n$$\n         \n         \n(利用 V* 和 Q* 的关系)\n\n**直观解读:**\n\n在状态 $s$ 采取动作 $a$ 的**最优价值 ($Q^*(s, a)$)** 等于：\n\n1.  获得即时奖励 $R(s, a, s')$。\n2.  转移到后继状态 $s'$。\n3.  在后继状态 $s'$，采取**最优**的下一个动作 $a'$ (即 $\\max_{a'} Q^*(s', a')$，这等价于 $V^*(s')$)。\n4.  将即时奖励和后继状态的最优折扣价值加起来，并对所有可能的后继状态 $s'$ 求期望。\n\n::: {.callout-note title=\"期望方程 vs. 最优方程\"}\n*   **Bellman 期望方程:** 用于**评估**一个给定的策略 $\\pi$，计算 $V_{\\pi}$ 或 $Q_{\\pi}$。它是一个线性方程组（如果状态动作空间有限）。\n*   **Bellman 最优方程:** 用于描述**最优**价值函数 $V^*$ 或 $Q^*$ 满足的条件。由于 `max` 操作的存在，它是一个非线性方程组。求解这个方程组就能得到最优价值函数，进而得到最优策略。\n:::\n\n## 最优方程的作用\n\nBellman 最优方程在强化学习中扮演着至关重要的角色，主要体现在以下几个方面：\n\n1. **理论基石:** 为强化学习算法提供了坚实的理论基础，证明了最优价值函数和最优策略的存在性。\n\n2. **算法设计指导:** 许多经典强化学习算法（如值迭代、策略迭代、Q-learning）都是基于 Bellman 最优方程设计的。\n\n3. **最优策略求解:** 通过求解 Bellman 最优方程，可以直接得到最优价值函数 $V^*$ 和 $Q^*$，进而推导出最优策略 $\\pi^*$。\n\n4. **收敛性保证:** 在满足一定条件下，基于 Bellman 最优方程的算法能够保证收敛到最优解。\n\n5. **价值函数更新:** 为价值函数的更新提供了明确的数学公式，指导智能体如何根据经验改进其价值估计。\n\n6. **策略改进:** 通过比较当前策略与最优价值函数，可以系统地改进策略，使其逐步接近最优。\n\n7. **理论分析工具:** 可用于分析强化学习算法的收敛速度、样本复杂度等理论性质。\n\n8. **实际应用指导:** 为实际应用中的策略优化提供了明确的方向，帮助设计更有效的学习算法。\n\n::: {.callout-note title=\"最优方程 vs. 期望方程\"}\n* **最优方程**用于寻找最优策略，包含最大化操作，是非线性方程\n* **期望方程**用于评估特定策略，是线性方程\n* 两者都基于 Bellman 方程，但目标不同\n:::\n\n## 实际应用中的选择\n\n在实际应用中，我们通常需要根据具体问题和计算资源在期望方程和最优方程之间做出选择：\n\n1. **期望方程的应用场景:**\n   * 当我们需要评估某个特定策略的性能时\n   * 在策略迭代算法中，用于策略评估阶段\n   * 当状态空间较大时，作为近似求解的起点\n   * 在在线学习中，用于实时更新策略价值\n\n2. **最优方程的应用场景:**\n   * 当我们的目标是找到最优策略时\n   * 在值迭代算法中，直接用于寻找最优价值函数\n   * 在Q-learning等off-policy算法中，用于更新最优动作值函数\n   * 当计算资源充足时，用于精确求解\n\n3. **实际考虑因素:**\n   * **计算复杂度:** 最优方程由于包含max操作，通常比期望方程更难求解\n   * **状态空间大小:** 对于大规模问题，通常需要结合近似方法\n   * **收敛速度:** 期望方程有时可以更快收敛，但可能陷入次优解\n   * **应用需求:** 如果只需要一个可行的好策略，期望方程可能就足够了\n\n::: {.callout-tip title=\"实际应用建议\"}\n* 对于小规模问题，可以直接求解最优方程\n* 对于大规模问题，建议采用近似方法或结合使用两种方程\n* 在策略迭代中交替使用两种方程往往能取得较好效果\n* 考虑使用函数逼近等方法来降低计算复杂度\n:::\n\n4. **折中方案:**\n   * 使用期望方程作为初始近似，逐步向最优方程过渡\n   * 在策略迭代中交替使用期望方程和最优方程\n   * 采用近似方法（如函数逼近）来降低最优方程的求解难度\n\n::: {.callout-warning title=\"注意事项\"}\n* 虽然 Bellman 最优方程在理论上非常强大，但在实际应用中，由于状态空间可能非常大或连续，直接求解往往不可行\n* 奖励函数的设计会显著影响最优策略的质量\n* 在实际应用中，通常需要在最优性和计算效率之间进行权衡\n:::\n\n\n## 理解“最优”的含义\n\n*   **最大化预期累积折扣回报:** 最优策略旨在最大化从任何状态开始的长期期望回报 $G_t$。\n*   **不一定是单步最优:** 最优策略有时可能需要采取一个即时奖励较低的动作，以便进入一个更有利的未来状态，从而获得更高的长期回报（“牺牲小我，完成大我”）。\n*   **可能存在多个最优策略:** 对于同一个 MDP，可能存在多个不同的策略都能达到相同的最优价值函数 $V^*$ 和 $Q^*$。\n*   **依赖于 MDP 定义:** 最优性是相对于给定的状态空间 $S$、动作空间 $A$、转移概率 $P$、奖励函数 $R$ 和折扣因子 $\\gamma$ 而言的。改变其中任何一个，最优策略和价值函数都可能改变。\n\n::: {.callout-warning title=\"奖励设计的关键性\"}\n奖励函数 $R$ 直接定义了智能体的目标。如果奖励函数设计不当（例如，只奖励短期行为而忽略长期后果），即使找到了该奖励函数下的“最优”策略，也可能无法实现真正的商业目标。设计一个能够准确反映长期商业价值的奖励函数是 RL 应用中的核心挑战。\n:::\n\n# Lab 1 (热身): 熟悉 Gym/Gymnasium 环境\n\n本周的实验课旨在让大家动手实践，熟悉强化学习实验的基本流程和工具。\n\n## 目标\n\n1.  **安装并配置 Gym/Gymnasium 环境:** 确保大家都能成功运行基本的 Gym 脚本。\n2.  **理解环境交互循环:** 掌握 `reset`, `step`, `render` 等核心函数的使用。\n3.  **观察 $S, A, R:$ 运行一个简单的随机策略智能体，观察状态、动作、奖励的变化。\n4.  **概念练习:** 将一个简单的商业场景映射到 Gym 环境的要素。\n\n## 步骤\n\n1.  **环境安装检查:**\n    *   确保你已经按照上周讲义的指导，在虚拟环境中安装了 `gymnasium` 和 `gymnasium[classic_control]`。\n    *   尝试运行上周提供的 CartPole 随机智能体示例代码，确保能看到可视化窗口并且代码正常运行。\n\n2.  **运行随机智能体:**\n    *   仔细阅读 CartPole 示例代码。\n    *   尝试修改代码：\n        *   改变 `range(1000)` 中的数字，看看一个回合能持续多少步。\n        *   去掉 `time.sleep(1)`，观察运行速度。\n        *   尝试另一个简单的环境，如 \"MountainCar-v0\" 或 \"Acrobot-v1\" (如果已安装 `box2d-py`，可以尝试 \"LunarLander-v2\")。观察它们的状态空间、动作空间和奖励结构有何不同。\n        ```python\n        import gymnasium as gym\n        # env = gym.make(\"MountainCar-v0\", render_mode=\"human\")\n        # env = gym.make(\"Acrobot-v1\", render_mode=\"human\")\n        # env = gym.make(\"LunarLander-v2\", render_mode=\"human\") # 需要 box2d\n        # ... (其余代码类似 CartPole)\n        ```\n    *   **思考:** 随机策略在这些环境中的表现如何？为什么？\n\n3.  **理解环境交互循环:**\n    *   在 `step` 函数前后打印 `observation`, `action`, `reward`, `terminated`, `truncated` 的值。\n    *   理解 `terminated` 和 `truncated` 的区别：\n        *   `terminated`: 环境达到了自然的终点（成功或失败）。\n        *   `truncated`: 环境因为外部限制（如时间步数）而提前结束。\n    *   查看 `env.observation_space` 和 `env.action_space`，了解状态和动作的类型与范围。\n\n4.  **练习：定义简单商业场景为 Gym 环境 (概念或简化代码)**\n\n    选择一个简单的商业场景，例如：\n\n    *   **单商品库存管理:**\n        *   目标：决定每天订购多少商品以最大化利润。\n        *   **状态 ($S$):** 当前库存水平 (离散或连续？)。可以简化为几个等级，如 [低, 中, 高]。\n        *   **动作 ($A$):** 订购数量 (离散？)。可以简化为 [不订购, 订购少量, 订购大量]。\n        *   **奖励 ($R$):** (销售收入) - (订购成本) - (库存持有成本) - (缺货惩罚)。如何量化这些值？\n        *   **转移概率 ($P$):** 假设已知每天的需求概率分布。根据当前库存、订购量和实际需求，计算下一天的库存水平。\n        *   **折扣因子 ($\\gamma$):** 如何选择？取决于关注短期利润还是长期稳定？\n\n    *   **简单广告投放:**\n        *   目标：决定在哪个渠道投放广告以最大化点击率或转化率。\n        *   **状态 ($S$):** 可以简化为当前日期是工作日还是周末？或者用户的某个简单分类？\n        *   **动作 ($A$):** 选择渠道 A 或渠道 B。\n        *   **奖励 ($R$):** 该渠道带来的点击次数或转化价值。\n        *   **转移概率 ($P$):** 状态转移可能很简单（如第二天），或者依赖于用户行为。\n        *   **折扣因子 ($\\gamma$):** 如果只关心单次投放效果，$\\gamma$ 可以为 0。如果考虑长期影响，$\\gamma > 0$。\n\n    **任务:**\n    *   选择一个场景。\n    *   **概念设计:** 清晰地定义 $S, A, R, P$ (可以描述性地说明转移逻辑), $\\gamma$。\n    *   **(可选) 简化代码框架:** 尝试编写一个 Python 类，模仿 Gym 环境的接口 (`__init__`, `reset`, `step`)。不需要完全实现复杂的逻辑，重点是定义接口和数据结构。\n\n    ```python\n    import gymnasium as gym\n    from gymnasium import spaces\n    import numpy as np\n\n    class SimpleInventoryEnv(gym.Env):\n        metadata = {'render_modes': [], 'render_fps': 4} # 元数据\n\n        def __init__(self, max_inventory=20, max_order=5, demand_dist=[0.1, 0.6, 0.3]):\n            super().__init__() # 调用父类构造函数\n\n            self.max_inventory = max_inventory\n            self.max_order = max_order\n            self.demand_dist = demand_dist # 假设需求是 0, 1, 2 的概率\n            self.possible_demands = np.arange(len(demand_dist))\n\n            # 定义状态空间：库存水平 (0 到 max_inventory)\n            self.observation_space = spaces.Discrete(max_inventory + 1)\n\n            # 定义动作空间：订购数量 (0 到 max_order)\n            self.action_space = spaces.Discrete(max_order + 1)\n\n            # 内部状态变量\n            self._current_inventory = 0\n\n        def _get_obs(self):\n            return self._current_inventory\n\n        def _get_info(self):\n            # 可以返回一些辅助信息，例如实际需求量\n            # return {\"demand\": self._last_demand}\n            return {}\n\n        def reset(self, seed=None, options=None):\n            super().reset(seed=seed) # 处理随机种子\n\n            # 重置库存为 0 (或其他初始值)\n            self._current_inventory = 0\n            observation = self._get_obs()\n            info = self._get_info()\n            return observation, info\n\n        def step(self, action):\n            # 1. 获取订购量 (动作)\n            order_quantity = action\n\n            # 2. 计算订购后的库存 (假设立即到货)\n            inventory_after_order = self._current_inventory + order_quantity\n            # 限制最大库存\n            inventory_after_order = min(inventory_after_order, self.max_inventory)\n\n            # 3. 模拟随机需求\n            demand = self.np_random.choice(self.possible_demands, p=self.demand_dist)\n            self._last_demand = demand # 记录需求，可选\n\n            # 4. 计算满足的需求 (销售量)\n            sales = min(inventory_after_order, demand)\n\n            # 5. 计算下一时刻的库存\n            self._current_inventory = inventory_after_order - sales\n\n            # 6. 计算奖励 (简化示例)\n            # 假设：售价=10, 订购成本=3, 持有成本=1, 缺货惩罚=2\n            revenue = sales * 10\n            order_cost = order_quantity * 3\n            holding_cost = self._current_inventory * 1 # 期末库存持有成本\n            shortage_cost = max(0, demand - inventory_after_order) * 2 # 缺货成本\n\n            reward = revenue - order_cost - holding_cost - shortage_cost\n\n            # 7. 确定是否结束 (在这个简单模型中，可以假设永不结束)\n            terminated = False\n            truncated = False # 也可以设置最大步数\n\n            observation = self._get_obs()\n            info = self._get_info()\n\n            return observation, reward, terminated, truncated, info\n\n        def render(self):\n            # 这个简单环境不需要可视化\n            pass\n\n        def close(self):\n            pass\n\n    # --- 如何使用 ---\n    # env = SimpleInventoryEnv()\n    # observation, info = env.reset()\n    # for _ in range(100):\n    #    action = env.action_space.sample() # 随机选择订购量\n    #    observation, reward, terminated, truncated, info = env.step(action)\n    #    print(f\"Inv: {observation}, Action: {action}, Reward: {reward}\")\n    #    if terminated or truncated:\n    #        break\n    # env.close()\n\n    ```\n\n## 提交要求\n\n*   确保你的 Python 环境可以运行 Gym/Gymnasium 示例。\n*   完成商业场景的概念设计 ($S, A, R, P, \\gamma$)。\n*   (可选) 提交你尝试编写的简化 Gym 环境代码框架。\n*   **思考:** 在你设计的商业场景中，马尔可夫性质是否容易满足？状态需要包含哪些信息才能更好地近似它？\n\n---\n\n**下周预告:** 开始学习无模型预测方法 - 蒙特卡洛 (Monte Carlo) 方法。"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles/custom.css"],"toc":true,"number-sections":false,"include-in-header":[{"text":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css\" integrity=\"sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xkm/sYwpb+ilR5gUw==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\">\n"}],"output-file":"week3_lecture.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","callout-appearance":"none","title":"Week 3: 最优决策与 Bellman 最优方程"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}